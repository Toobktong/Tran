<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î Lat Long ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        @font-face {
            font-family: 'TH Sarabun';
            src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-06@1.0/TH Sarabun.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'TH Sarabun', Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            color: white;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .upload-section {
            text-align: center;
            padding: 40px 20px;
        }
        
        .upload-area {
            border: 3px dashed #ccc;
            border-radius: 10px;
            padding: 40px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #f9f9f9;
        }
        
        .upload-area:hover {
            border-color: #667eea;
            background-color: #f0f4ff;
        }
        
        .upload-area.dragover {
            border-color: #667eea;
            background-color: #e1e8ff;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #555;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .sample-data {
            background: #e3f2fd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            text-align: left;
        }
        
        .sample-data h3 {
            margin-bottom: 10px;
            color: #1976d2;
        }
        
        .sample-data pre {
            background: #fff;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1rem;
        }
        
        .settings-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .setting-group {
            flex: 1;
            min-width: 250px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1.2rem;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1.1rem;
        }
        
        .info-text {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }
        
        .results-section {
            display: none;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-header h2 {
            font-size: 1.8rem;
        }
        
        .clusters-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .cluster-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }
        
        .cluster-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .cluster-title {
            font-weight: 600;
            color: #333;
            font-size: 1.3rem;
        }
        
        .cluster-count {
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 1.1rem;
        }
        
        .cluster-items {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .cluster-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .cluster-item:last-child {
            border-bottom: none;
        }
        
        .item-name {
            font-weight: 500;
            color: #444;
            font-size: 1.2rem;
        }
        
        .item-coords {
            font-size: 1.1rem;
            color: #666;
            margin-top: 3px;
        }
        
        .summary-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            margin-top: 20px;
        }
        
        .summary-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        
        .summary-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .error-message {
            color: #e74c3c;
            text-align: center;
            padding: 20px;
            background: #ffeaea;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
            font-size: 1.2rem;
        }
        
        .loading {
            text-align: center;
            padding: 30px;
            display: none;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #667eea;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .settings-section {
                flex-direction: column;
            }
            
            .clusters-container {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .results-header {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î Lat Long ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô</h1>
            <p class="subtitle">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏±‡∏ô (‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ñ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á)</p>
        </header>
        
        <main>
            <div class="card upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <p class="upload-text">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV ‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</p>
                    <p class="upload-text" style="font-size: 1.1rem; opacity: 0.7;">(‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå "A ‡∏ä‡∏∑‡πà‡∏≠" ‡πÅ‡∏•‡∏∞ "B ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î")</p>
                    <button class="btn" id="browseBtn">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå</button>
                    <input type="file" id="fileInput" class="file-input" accept=".csv">
                </div>
                
                <div class="sample-data">
                    <h3>‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå CSV:</h3>
                    <pre>"A ‡∏ä‡∏∑‡πà‡∏≠","B ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î"
"‡πÇ‡∏£‡∏á‡∏û‡∏¢‡∏≤‡∏ö‡∏≤‡∏•‡πÅ‡∏´‡πà‡∏á‡∏ä‡∏≤‡∏ï‡∏¥","13.7563,100.5018"
"‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢‡∏ò‡∏£‡∏£‡∏°‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå","13.7592,100.4998"
"‡∏™‡∏¢‡∏≤‡∏°‡∏û‡∏≤‡∏£‡∏≤‡∏Å‡∏≠‡∏ô","13.7466,100.5346"
"‡∏™‡∏ô‡∏≤‡∏°‡∏ö‡∏¥‡∏ô‡∏™‡∏∏‡∏ß‡∏£‡∏£‡∏ì‡∏†‡∏π‡∏°‡∏¥","13.6899,100.7501"
"‡πÄ‡∏ã‡πá‡∏ô‡∏ó‡∏£‡∏±‡∏•‡πÄ‡∏ß‡∏¥‡∏•‡∏î‡πå","13.7470,100.5360"</pre>
                </div>
                
                <div class="error-message" id="errorMessage"></div>
            </div>
            
            <div class="card settings-section">
                <div class="setting-group">
                    <label for="distanceThreshold">‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡∏Å‡∏¥‡πÇ‡∏•‡πÄ‡∏°‡∏ï‡∏£):</label>
                    <input type="number" id="distanceThreshold" value="5" min="0.1" step="0.1">
                    <div class="info-text">‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ñ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏£‡∏á)</div>
                </div>
                <div class="setting-group">
                    <label for="algorithm">‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ò‡∏∂‡∏°:</label>
                    <select id="algorithm">
                        <option value="simple">Simple Clustering</option>
                        <option value="dbscan">DBSCAN (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>&nbsp;</label>
                    <button class="btn" id="processBtn" disabled>‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
                </div>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•... (‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà)</p>
            </div>
            
            <div class="results-section" id="resultsSection">
                <div class="results-header">
                    <h2>‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</h2>
                    <div>
                        <button class="btn" id="downloadCSVBtn" style="margin-right: 10px;">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î CSV</button>
                        <button class="btn" id="downloadExcelBtn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Excel</button>
                    </div>
                </div>
                
                <div class="clusters-container" id="clustersContainer"></div>
                
                <div class="summary-card">
                    <div class="summary-title">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå</div>
                    <div class="summary-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="totalPoints">0</div>
                            <div class="stat-label">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="clusterCount">0</div>
                            <div class="stat-label">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avgDistance">0</div>
                            <div class="stat-label">‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (‡∏Å‡∏°.)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="pairCount">0</div>
                            <div class="stat-label">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ</div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        let pointsData = [];
        let clusteredData = [];
        let distanceMatrix = []; // ‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏à‡∏∏‡∏î
        let pairData = []; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ
        
        // ‡∏≠‡∏á‡∏Ñ‡πå‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö DOM
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const browseBtn = document.getElementById('browseBtn');
        const processBtn = document.getElementById('processBtn');
        const errorMessage = document.getElementById('errorMessage');
        const loading = document.getElementById('loading');
        const resultsSection = document.getElementById('resultsSection');
        const clustersContainer = document.getElementById('clustersContainer');
        const distanceThreshold = document.getElementById('distanceThreshold');
        
        // Event Listeners
        browseBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        processBtn.addEventListener('click', processClustering);
        document.getElementById('downloadCSVBtn').addEventListener('click', downloadCSV);
        document.getElementById('downloadExcelBtn').addEventListener('click', downloadExcel);
        
        // Drag and drop events
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect();
            }
        });
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå
        function handleFileSelect() {
            const file = fileInput.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                showError('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå CSV ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parseCSV(e.target.result);
                    processBtn.disabled = false;
                    showError('');
                } catch (error) {
                    showError('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: ' + error.message);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á CSV ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) {
                throw new Error('‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠');
            }
            
            pointsData = [];
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö header row
            const headerLine = lines[0];
            const headers = parseCSVRow(headerLine);
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            const nameColumnIndex = headers.findIndex(h => h.trim() === 'A ‡∏ä‡∏∑‡πà‡∏≠');
            const coordsColumnIndex = headers.findIndex(h => h.trim() === 'B ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î');
            
            if (nameColumnIndex === -1 || coordsColumnIndex === -1) {
                throw new Error('‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå "A ‡∏ä‡∏∑‡πà‡∏≠" ‡πÅ‡∏•‡∏∞ "B ‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î,‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î"');
            }
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue;
                
                const values = parseCSVRow(line);
                if (values.length > Math.max(nameColumnIndex, coordsColumnIndex)) {
                    const name = values[nameColumnIndex];
                    const coords = values[coordsColumnIndex];
                    
                    if (coords) {
                        const coordParts = coords.split(',');
                        if (coordParts.length >= 2) {
                            const lat = parseFloat(coordParts[0]);
                            const lng = parseFloat(coordParts[1]);
                            
                            if (!isNaN(lat) && !isNaN(lng)) {
                                pointsData.push({
                                    name: name,
                                    lat: lat,
                                    lng: lng
                                });
                            }
                        }
                    }
                }
            }
            
            if (pointsData.length === 0) {
                throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå');
            }
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏¢‡∏Å CSV row ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö quoted values
        function parseCSVRow(row) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                if (char === '"') {
                    if (inQuotes && i + 1 < row.length && row[i + 1] === '"') {
                        // Double quotes inside quoted field
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quotes
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add last field
            result.push(current.trim());
            return result;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ñ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á (OSRM API - ‡∏à‡∏≥‡∏•‡∏≠‡∏á)
        // ‡πÉ‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ñ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏£‡∏á
        function calculateRoadDistance(lat1, lon1, lat2, lon2) {
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏£‡∏á‡∏Å‡πà‡∏≠‡∏ô
            const straightDistance = calculateStraightDistance(lat1, lon1, lat2, lon2);
            
            // ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Ñ‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏°‡∏ñ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á (‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 20-40% ‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏£‡∏á)
            // ‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏Å‡∏£‡∏ì‡∏µ
            const roadDistance = straightDistance * (1 + Math.random() * 0.3 + 0.1);
            
            return roadDistance;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏£‡∏á (Haversine formula)
        function calculateStraightDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // ‡∏£‡∏±‡∏®‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡πÇ‡∏•‡∏Å‡πÉ‡∏ô‡∏Å‡∏¥‡πÇ‡∏•‡πÄ‡∏°‡∏ï‡∏£
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Distance Matrix
        function buildDistanceMatrix(points) {
            const matrix = [];
            const n = points.length;
            
            for (let i = 0; i < n; i++) {
                matrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        matrix[i][j] = 0;
                    } else {
                        matrix[i][j] = calculateRoadDistance(
                            points[i].lat, points[i].lng,
                            points[j].lat, points[j].lng
                        );
                    }
                }
            }
            
            return matrix;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Distance Matrix
        function simpleClusteringWithMatrix(points, matrix, threshold) {
            const clusters = [];
            const visited = new Array(points.length).fill(false);
            const pairList = []; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ
            
            for (let i = 0; i < points.length; i++) {
                if (visited[i]) continue;
                
                const cluster = [points[i]];
                visited[i] = true;
                
                // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
                let closestPoint = null;
                let closestDistance = Infinity;
                let closestIndex = -1;
                
                for (let j = 0; j < points.length; j++) {
                    if (visited[j] || i === j) continue;
                    
                    const distance = matrix[i][j];
                    
                    if (distance <= threshold && distance < closestDistance) {
                        closestDistance = distance;
                        closestPoint = points[j];
                        closestIndex = j;
                    }
                }
                
                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà
                if (closestPoint) {
                    cluster.push(closestPoint);
                    visited[closestIndex] = true;
                    
                    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏π‡πà
                    pairList.push({
                        point1: points[i],
                        point2: closestPoint,
                        distance: closestDistance
                    });
                }
                
                clusters.push(cluster);
            }
            
            pairData = pairList;
            return clusters;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô DBSCAN ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ Distance Matrix
        function dbscanClusteringWithMatrix(points, matrix, eps, minPts) {
            const clusters = [];
            const visited = new Array(points.length).fill(false);
            const clusterLabels = new Array(points.length).fill(-1);
            let clusterId = 0;
            const pairList = []; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ
            
            for (let i = 0; i < points.length; i++) {
                if (visited[i]) continue;
                
                visited[i] = true;
                const neighbors = getNeighborsFromMatrix(matrix, i, eps);
                
                if (neighbors.length < minPts) {
                    // Noise point
                    clusterLabels[i] = -1;
                } else {
                    // Core point
                    clusterLabels[i] = clusterId;
                    expandClusterWithMatrix(matrix, i, neighbors, clusterLabels, visited, clusterId, eps, minPts);
                    clusterId++;
                }
            }
            
            // ‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏° clusterLabels
            for (let i = 0; i < clusterId; i++) {
                const cluster = [];
                for (let j = 0; j < points.length; j++) {
                    if (clusterLabels[j] === i) {
                        cluster.push(points[j]);
                    }
                }
                if (cluster.length > 0) {
                    clusters.push(cluster);
                }
            }
            
            // ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÉ‡∏î
            const noisePoints = [];
            for (let i = 0; i < points.length; i++) {
                if (clusterLabels[i] === -1) {
                    noisePoints.push([points[i]]);
                }
            }
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏π‡πà‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ 2 ‡∏à‡∏∏‡∏î
            clusters.forEach(cluster => {
                if (cluster.length === 2) {
                    const point1Index = pointsData.findIndex(p => p.name === cluster[0].name);
                    const point2Index = pointsData.findIndex(p => p.name === cluster[1].name);
                    
                    if (point1Index !== -1 && point2Index !== -1) {
                        pairList.push({
                            point1: cluster[0],
                            point2: cluster[1],
                            distance: matrix[point1Index][point2Index]
                        });
                    }
                }
            });
            
            pairData = pairList;
            return clusters.concat(noisePoints);
        }
        
        function getNeighborsFromMatrix(matrix, pointIdx, eps) {
            const neighbors = [];
            for (let i = 0; i < matrix.length; i++) {
                if (i === pointIdx) continue;
                if (matrix[pointIdx][i] <= eps) {
                    neighbors.push(i);
                }
            }
            return neighbors;
        }
        
        function expandClusterWithMatrix(matrix, pointIdx, neighbors, clusterLabels, visited, clusterId, eps, minPts) {
            let i = 0;
            while (i < neighbors.length) {
                const neighborIdx = neighbors[i];
                if (!visited[neighborIdx]) {
                    visited[neighborIdx] = true;
                    const neighborNeighbors = getNeighborsFromMatrix(matrix, neighborIdx, eps);
                    if (neighborNeighbors.length >= minPts) {
                        neighbors = neighbors.concat(neighborNeighbors.filter(idx => !neighbors.includes(idx)));
                    }
                }
                if (clusterLabels[neighborIdx] === -1) {
                    clusterLabels[neighborIdx] = clusterId;
                }
                i++;
            }
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°
        function processClustering() {
            if (pointsData.length === 0) {
                showError('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•');
                return;
            }
            
            showLoading(true);
            
            // ‡πÉ‡∏ä‡πâ setTimeout ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ UI ‡πÑ‡∏î‡πâ‡πÅ‡∏™‡∏î‡∏á loading
            setTimeout(() => {
                try {
                    const threshold = parseFloat(distanceThreshold.value) || 5;
                    const algorithm = document.getElementById('algorithm').value;
                    
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á Distance Matrix
                    distanceMatrix = buildDistanceMatrix(pointsData);
                    
                    let clusters;
                    if (algorithm === 'dbscan') {
                        clusters = dbscanClusteringWithMatrix(pointsData, distanceMatrix, threshold, 2);
                    } else {
                        clusters = simpleClusteringWithMatrix(pointsData, distanceMatrix, threshold);
                    }
                    
                    clusteredData = clusters;
                    displayResults(clusters);
                    showLoading(false);
                    resultsSection.style.display = 'block';
                } catch (error) {
                    showLoading(false);
                    showError('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: ' + error.message);
                }
            }, 100);
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
        function displayResults(clusters) {
            clustersContainer.innerHTML = '';
            
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            let totalPoints = 0;
            let totalDistance = 0;
            let distanceCount = 0;
            
            clusters.forEach((cluster, index) => {
                totalPoints += cluster.length;
                
                const clusterCard = document.createElement('div');
                clusterCard.className = 'cluster-card';
                
                const clusterHeader = document.createElement('div');
                clusterHeader.className = 'cluster-header';
                
                const clusterTitle = document.createElement('div');
                clusterTitle.className = 'cluster-title';
                clusterTitle.textContent = `‡∏Å‡∏•‡∏∏‡πà‡∏° ${index + 1}`;
                
                const clusterCount = document.createElement('div');
                clusterCount.className = 'cluster-count';
                clusterCount.textContent = cluster.length;
                
                clusterHeader.appendChild(clusterTitle);
                clusterHeader.appendChild(clusterCount);
                
                const clusterItems = document.createElement('div');
                clusterItems.className = 'cluster-items';
                
                cluster.forEach(point => {
                    const item = document.createElement('div');
                    item.className = 'cluster-item';
                    
                    const itemName = document.createElement('div');
                    itemName.className = 'item-name';
                    itemName.textContent = point.name;
                    
                    const itemCoords = document.createElement('div');
                    itemCoords.className = 'item-coords';
                    itemCoords.textContent = `${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}`;
                    
                    item.appendChild(itemName);
                    item.appendChild(itemCoords);
                    clusterItems.appendChild(item);
                });
                
                clusterCard.appendChild(clusterHeader);
                clusterCard.appendChild(clusterItems);
                clustersContainer.appendChild(clusterCard);
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°
                if (cluster.length > 1) {
                    for (let i = 0; i < cluster.length; i++) {
                        for (let j = 0; j < cluster.length; j++) {
                            if (i !== j) {
                                const point1Index = pointsData.findIndex(p => p.name === cluster[i].name);
                                const point2Index = pointsData.findIndex(p => p.name === cluster[j].name);
                                
                                if (point1Index !== -1 && point2Index !== -1) {
                                    const distance = distanceMatrix[point1Index][point2Index];
                                    totalDistance += distance;
                                    distanceCount++;
                                }
                            }
                        }
                    }
                }
            });
            
            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            document.getElementById('totalPoints').textContent = totalPoints;
            document.getElementById('clusterCount').textContent = clusters.length;
            const avgDistance = distanceCount > 0 ? (totalDistance / distanceCount) : 0;
            document.getElementById('avgDistance').textContent = avgDistance.toFixed(2);
            document.getElementById('pairCount').textContent = pairData.length;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô loading
        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = message ? 'block' : 'none';
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î CSV
        function downloadCSV() {
            if (clusteredData.length === 0) return;
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á CSV ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏∏‡πà‡∏°
            let csvContent = '"‡∏Å‡∏•‡∏∏‡πà‡∏°","‡∏ä‡∏∑‡πà‡∏≠","‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î","‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î"\n';
            
            clusteredData.forEach((cluster, clusterIndex) => {
                cluster.forEach(point => {
                    csvContent += `"${clusterIndex + 1}","${point.name.replace(/"/g, '""')}","${point.lat}","${point.lng}"\n`;
                });
            });
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏° section ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ
            csvContent += '\n"‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ",,,\n';
            csvContent += '"‡∏•‡∏≥‡∏î‡∏±‡∏ö","‡∏ä‡∏∑‡πà‡∏≠ 1","‡∏ä‡∏∑‡πà‡∏≠ 2","‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á (‡∏Å‡∏°.)"\n';
            
            pairData.forEach((pair, index) => {
                csvContent += `"${index + 1}","${pair.point1.name.replace(/"/g, '""')}","${pair.point2.name.replace(/"/g, '""')}","${pair.distance.toFixed(2)}"\n`;
            });
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏° section ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°
            csvContent += '\n"‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°",,,\n';
            csvContent += '"‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î","‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°","‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ","‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (‡∏Å‡∏°.)"\n';
            csvContent += `"${pointsData.length}","${clusteredData.length}","${pairData.length}","${document.getElementById('avgDistance').textContent}"\n`;
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', '‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Excel
        function downloadExcel() {
            if (clusteredData.length === 0) return;
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á workbook
            const wb = XLSX.utils.book_new();
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á worksheet ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏∏‡πà‡∏°
            const clusterData = [
                ['‡∏Å‡∏•‡∏∏‡πà‡∏°', '‡∏ä‡∏∑‡πà‡∏≠', '‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î', '‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î']
            ];
            
            clusteredData.forEach((cluster, clusterIndex) => {
                cluster.forEach(point => {
                    clusterData.push([
                        clusterIndex + 1,
                        point.name,
                        point.lat,
                        point.lng
                    ]);
                });
            });
            
            const ws1 = XLSX.utils.aoa_to_sheet(clusterData);
            XLSX.utils.book_append_sheet(wb, ws1, '‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î');
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á worksheet ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ
            const pairDataSheet = [
                ['‡∏•‡∏≥‡∏î‡∏±‡∏ö', '‡∏ä‡∏∑‡πà‡∏≠ 1', '‡∏ä‡∏∑‡πà‡∏≠ 2', '‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á (‡∏Å‡∏°.)']
            ];
            
            pairData.forEach((pair, index) => {
                pairDataSheet.push([
                    index + 1,
                    pair.point1.name,
                    pair.point2.name,
                    parseFloat(pair.distance.toFixed(2))
                ]);
            });
            
            const ws2 = XLSX.utils.aoa_to_sheet(pairDataSheet);
            XLSX.utils.book_append_sheet(wb, ws2, '‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ');
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á worksheet ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°
            const summaryData = [
                ['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏à‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°', '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡πÑ‡∏î‡πâ', '‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ (‡∏Å‡∏°.)'],
                [
                    pointsData.length,
                    clusteredData.length,
                    pairData.length,
                    parseFloat(document.getElementById('avgDistance').textContent)
                ]
            ];
            
            const ws3 = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, ws3, '‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°');
            
            // ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå
            XLSX.writeFile(wb, '‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î.xlsx');
        }
    </script>
</body>
</html>